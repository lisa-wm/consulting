---
title: "Web Scraping"
author: "Asmik & Lisa -- for Intro to NLP"
date: "30 April 2021"
output:
  html_document: default
  pdf_document: default
---

![](../../Logo_Consulting.JPG)

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

## Web Scraping from the IMDb Website

This demo is about basic **web scraping**.

We show how to parse (static) HTML content, extract relevant information, and store it in an R-friendly manner.

```{r setup_packages, message=FALSE, warning=FALSE}
# Load required packages

library(tidyverse)
library(rvest)
library(stringr)
library(xml2)
```

### Get contents

Specify URL for desired website to be scraped (<http://www.imdb.com/chart/top?ref_=nv_mv_250_6>) and parse website contents:

```{r cars}

(url <- xml2::read_html("http://www.imdb.com/chart/top?ref_=nv_mv_250_6"))

```

### Explore contents

Website contents do not come in nice tabular form -- we need to access them using HTML nodes / CSS selectors (actual content is written in HTML, whereas CSS is responsible for style elements).

HTML nodes can be found via the developer tab (F12) in Google Chrome or using helper tools like [SelectorGadget](https://selectorgadget.com/) (including video tutorial).

Let's see what our IMDb website looks like using the developer tab.
Chrome offers a feature that lets us hover over the website and display the corresponding source code section.
We inspect the title element "Top Rated Movies":

![](screenshot_devtool_1.PNG)

***

The title element is apparently of class `header`.
We obtain the same result using SelectorGadget (see pane in bottom-right corner):

![](screenshot_selectorgadget_2.PNG)

### Get movie titles

Using SelectorGadget once more, we find the movie titles to be stored in an element called `.titleColumn a` (note that SelectorGadget separates selectors by comma):

![](screenshot_selectorgadget_3.PNG)

***

Once we have found this (which might take a while if the website structure is nested, so prepare for some trial-and-error here), `rvest` makes the rest rather convenient:

```{r title}
title_data <- rvest::html_nodes(url, ".titleColumn a") %>% 
  rvest::html_text()
```

```{r title_1}
head(title_data)
```

### Get release years

In order to scrape the movies' year of release, we check again for the corresponding selector, this time using the developer pane:

![](screenshot_devtool_2.PNG)

```{r year}
year_data <- rvest::html_nodes(url, ".secondaryInfo") %>% 
  rvest::html_text()
```

```{r year_1}
head(year_data)
```

Most of the time, we will need to clean the data after scraping.
We extract the years without parentheses (more on regular expressions coming soon) and convert to numeric: 

```{r year_clean}

(year_data_clean <- year_data %>% 
  stringr::str_replace_all(pattern = "[\\(\\)]", replacement = "") %>% 
  as.numeric())

```

### Get rankings

Now you know the selector drill, let's proceed to the movies' rankings.
The rankings are stored within `.titleColumn` but the numbering does not have a separate selector.

```{r rank}
rank_data <- rvest::html_nodes(url, ".titleColumn") %>% 
  rvest::html_text()
```

```{r rank_1}
head(rank_data)
```

We clean the extracted ranking data and convert to numeric, by first removing unwanted characters and white spaces...

```{r rank_clean}

rank_data_clean <- rank_data %>% 
  stringr::str_replace_all(pattern = "\n", replacement = "") %>%
  stringr::str_squish()

head(rank_data_clean)
```

... and then extracting, for each entry, the number before the dot:

```{r rank_clean_2}

(rank_data_clean <- sapply(
  rank_data_clean,
  function(i) unlist(stringr::str_split(i, pattern = "\\."))[1]) %>% 
  as.numeric())

```

### Get ratings

The ratings are easier to handle:

```{r rating}
rating_data <- rvest::html_nodes(url, "strong") %>% 
  rvest::html_text()

head(rating_data)
```

Convert ratings to numeric:

```{r rating_clean}
(rating_data_clean <- rating_data %>% 
  as.numeric())
```


### Store scraped data

Now we have everything we need and can store the data in an R-friendly object.

We will use a `data.frame` here. If you need to handle large data, you might want to consider using `data.table` instead, a powerful and very fast package for general data handling (its syntax is a bit different though).


```{r create_df}
imdb_scraped_data <- data.frame(
  ranking = rank_data_clean,
  title = title_data,
  year = year_data_clean,
  rating = rating_data_clean)

head(imdb_scraped_data)
```

**Nice, now we can use the movie data just like any other R object.**
![](screenshot_v.JPG)